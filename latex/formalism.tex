\title{CESK* / CFA Formalism}
\author{
	Davis Silverman
}
\date{}

\documentclass[12pt,draft]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{titling}
%\usepackage{bm}

\setlength{\droptitle}{-10em}  % Make title not in middle of page (uses titling package)
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-9mu+}}}
\setcounter{section}{-1}
\begin{document}

\newcommand{\lamsyn}[2]{(\lambda\;(#1 ...)\;#2)}
\newcommand{\letsyn}[3]{(\texttt{let}\;(#1\;#2)\;#3)}
\newcommand{\ifsyn}[3]{(\texttt{if}\;#1\;#2\;#3)}
\newcommand{\primsyn}[3]{(\texttt{prim}\;#1\;#2\;#3 ...)}
\newcommand{\truesyn}{\texttt{\#t}}
\newcommand{\falsesyn}{\texttt{\#f}}

% textit for semantic domains
% textsf for syntactic domains


\section{Formalization of a CESK* machine with basic Scheme features.}

\begin{align*}
\varsigma \in \Sigma &= \textsf{Exp} \times \textsf{Env} \times \textsf{Kont} \\
op \in \textit{Primitive} &\;\;\;\;\;\; \text{The set of primitves} \\
\mathit{clo} \in \mathit{Clo} &= \lamsyn{x}{e} \times \textsf{Env} \\
\textsf{Bool} &::= \truesyn \;|\; \falsesyn \\
v \in \textsf{AExp} &= \mathit{Clo} \;+\; \textsf{Bool} \;+\; \mathbb{Z} \\
x \in \textsf{Var} &\;\;\;\;\;\; \text{A set of identifiers} \\
e \in \textsf{Exp} &::= x  \;|\; v \;|\; \lamsyn{x}{e} \\
				  &	\;\;\;\;\;\;\;\;\; \;|\; \ifsyn{e}{e}{e}  \\
				  &	\;\;\;\;\;\;\;\;\; \;|\; \letsyn{x}{e}{e} \\
				  &	\;\;\;\;\;\;\;\;\; \;|\; \primsyn{op}{e}{e} \\
				  &	\;\;\;\;\;\;\;\;\; \;|\; (e \; e \; ...) \\
a,b,c \in \textit{Addr} &\;\;\;\;\;\; \text{A set of addresses} \\
\rho \in \textsf{Env} &= \textsf{Var} \rightharpoonup \textit{Addr} \\
\sigma \in \textsf{Store} &= \textit{Addr} \rightharpoonup \textsf{AExp} \\
done &= \textsf{Val*} \\
todo &= \textsf{Exp*} \\
\kappa \in \textsf{Kont} &= \textbf{mt} \;|\; \textbf{appk}(done, todo, \rho, a) \\
					   &	\;\;\;\;\;\;\;\;\;\; \;|\; \textbf{ifk}(e, e, \rho, a) \\
					   &	\;\;\;\;\;\;\;\;\;\; \;|\; \textbf{letk}(x, e, \rho, a) \\
\\
alloc &: \Sigma \rightarrow Addr \\
alloc(\varsigma) &= \text{an unallocated address} \\
\text{Our transition function is of type} \\
(\Sigma \times \textsf{Store}) &\rightarrow (\Sigma \times \textsf{Store})
\end{align*}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Begin Semantics
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{center}
\begin{tabular}{l | r}
\multicolumn{2}{c}{$(\varsigma \times \sigma) \rightarrow (\varsigma' \times \sigma)$, 
where $\kappa = \sigma(a) , b = alloc(\varsigma) $} \\
\multicolumn{2}{c}{proceed by matching on $\varsigma$} \\
\hline
%%%%% VARLOOKUP EXP
$\langle
x , \rho , a
\rangle$
&$\langle
v , \rho , a
\rangle$ \\
& where $v = \sigma(\rho(x))$ \\
\hline
%%%%% LAMBDA EXP
$\langle
\lamsyn{x}{e} , \rho , a
\rangle$
&$\langle
\textbf{clo}(\lamsyn{x}{e}, \rho) , \rho , a 
\rangle$ \\
\hline
%%%%% IF EXP
$\langle
\ifsyn{e_c}{e_t}{e_f} , \rho , a
\rangle$
&$\langle
e_c , \rho , b 
\rangle$ \\
& $\sigma[b \mapsto \textbf{ifk}(e_t , e_f , \rho , a)]$ \\
\hline
%%%%% LET EXP
$\langle
\letsyn{x}{e_x}{e_b} , \rho , a
\rangle$
&$\langle
e_x , \rho , b
\rangle$ \\
& $\sigma[b \mapsto \textbf{letk}(x , e_b , \rho , a)]$ \\
\hline
%%%%% PRIM EXP
$\langle
\primsyn{op}{e_0}{es} , \rho , a
\rangle$
&$\langle
e_0 , \rho , b
\rangle$ \\
& $\sigma[b \mapsto \textbf{primk}(op , [] ,  es , \rho , a)]$ \\
trick for 0 arg prims? \\
What would I make ctrl? \\
Also should I merge \\ primk and appk \\
\hline
%%%%% APPLICATION EXP
$\langle
(e_f \; es ...) , \rho , a
\rangle$
&$\langle
e_f , \rho , b
\rangle$ \\
& $\sigma[b \mapsto \textbf{appk}([] , e_s , \rho , a)]$ \\
\hline
$\langle v , \rho , a \rangle$ & \\
match on $\kappa$ below \\
\hline
%%%%% MT KONTINUATION
$ \textbf{mt}$ 
& $\varsigma$ \\
\hline
%%%%% IF KONTINUATION FALSE
$ \textbf{ifk}(e_t , e_f , \rho' , c) $ 
& $\langle e_f , \rho' , c \rangle$ \\
where $v = \falsesyn$ & \\
\hline
%%%%% IF KONTINUATION TRUE
$ \textbf{ifk}(e_t , e_f , \rho' , c) $ 
& $\langle e_t , \rho' , c \rangle$ \\
where $v \not= \falsesyn$ & \\
\hline
%%%%% LET KONTINUATION
$ \textbf{letk}(x , e_b , \rho' , c) $ 
& $\langle e_b , \rho'[x \mapsto b] , c \rangle$ \\
& $ \sigma[b \mapsto v] $ \\
\hline
%%%%% PRIM KONTINUATION DONE
$ \textbf{primk}(op , done ,  [\;] , \rho' , c) $ 
& $\langle v' , \rho' , c \rangle$ \\
& $ v' = op $ applied to $(done \mdoubleplus [v])$ \\
\hline
%%%%% PRIM KONTINUATION MORE
$ \textbf{primk}(op , done ,  (h::t) , \rho' , c) $ 
& $\langle h , \rho' , b  \rangle$ \\
& $ \sigma[b \mapsto \textbf{primk}(op , done \mdoubleplus [v] , t , \rho' , c )] $ \\
\hline
%%%%% APP KONTINUATION DONE
$ \textbf{appk}((\textbf{clo}(\lamsyn{xs}{e_b} , \rho'') :: vs), $
& $\langle e_b , \rho''[xs_0 \mapsto b_0 ... xs_i \mapsto b_i] , c \rangle$ \\
$\;\;\;\;\;\;\;\;\;\;  [\;] , \rho' , c) $
& $ vs = vs \mdoubleplus [v] $ \\
& $ \sigma[b_0 \mapsto vs_0 ... b_i \mapsto vs_i] $  \\
\hline
%%%%% APP KONTINUATION MORE
$ \textbf{appk}(done, h::t , \rho' , c) $
& $\langle h , \rho' , b \rangle$ \\
& $ \sigma[b \mapsto \textbf{appk}(done \mdoubleplus [v] , t , \rho' , c)] $ \\
\hline
\end{tabular}
\end{center}












\newpage



\section{Formalization of an aCESK* machine with basic Scheme features.}


























\end{document}
  