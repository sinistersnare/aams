\title{CESK* / CFA Formalism}
\author{
	Davis Silverman
}
\date{}

\documentclass[12pt,draft]{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{titling}
%\usepackage{bm}

\setlength{\droptitle}{-10em}  % Make title not in middle of page (uses titling package)
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-9mu+}}}
\newcommand\mae{\ensuremath{\text{\ae}}}
\setcounter{section}{-1}
\begin{document}

\newcommand{\lamsyn}[2]{(\lambda\;(#1 ...)\;#2)}
\newcommand{\letsyn}[3]{(\texttt{let}\;(#1\;#2)\;#3)}
\newcommand{\ifsyn}[3]{(\texttt{if}\;#1\;#2\;#3)}
\newcommand{\primsyn}[3]{(\texttt{prim}\;#1\;#2\;#3 ...)}
\newcommand{\truesyn}{\texttt{\#t}}
\newcommand{\falsesyn}{\texttt{\#f}}

% textit for semantic domains
% textsf for syntactic domains


\section{Formalization of a CESK* machine with basic Scheme features.}


\begin{align*}
&\textbf{Syntax:} \\
e \in \textsf{Exp} &::= x  \;|\; \mae \;|\; lam \\
				  &	\;\;\;\;\;\;\;\;\; \;|\; \ifsyn{e}{e}{e}  \\
				  &	\;\;\;\;\;\;\;\;\; \;|\; \letsyn{x}{e}{e} \\
				  &	\;\;\;\;\;\;\;\;\; \;|\; \primsyn{op}{e}{e} \\
				  &	\;\;\;\;\;\;\;\;\; \;|\; (e \; e \; ...) \\
\mae \in \textsf{AExp} &= \mathit{Clo} \;+\; \textsf{Bool} \;+\; \mathbb{Z} \\
 \text{This doesnt feel right} &\Uparrow\; \text{Because Clo cant be constructed syntactically...} \\
lam \in \textsf{Lam} &::= \lamsyn{x}{e} \\
x \in \textsf{Var} &\;\;\;\;\;\; \text{A set of identifiers} \\
\textsf{Bool} &::= \truesyn \;|\; \falsesyn \\
done &= \textsf{AExp*} \\
todo &= \textsf{Exp*} \\
&\textbf{Semantics:} \\
\varsigma \in \Sigma &= \textsf{Exp} \times \textsf{Env} \times \textsf{Kont} \\
op \in \textit{Primitive} &\;\;\;\;\;\; \text{The set of primitves} \\
\mathit{clo} \in \mathit{Clo} &= lam \times \textsf{Env} \\
\rho \in \textit{Env} &= \textsf{Var} \rightharpoonup \textit{Addr} \\
\sigma \in \textsf{Store} &= \textit{Addr} \rightharpoonup \textsf{AExp} \\
\kappa \in \textit{Kont} &= \textbf{mt} \;|\; \textbf{appk}(done, todo, \rho, a) \\
					   &	\;\;\;\;\;\;\;\;\;\; \;|\; \textbf{ifk}(e, e, \rho, a) \\
					   &	\;\;\;\;\;\;\;\;\;\; \;|\; \textbf{letk}(x, e, \rho, a) \\
\\
alloc &: \Sigma \rightarrow Addr \\
alloc(\varsigma) &= \text{an unallocated address} \\
\textbf{Transition}&\textbf{ Function:} \\
(\Sigma \times \textsf{Store}) &\rightarrow (\Sigma \times \textsf{Store}) \\
\end{align*}


\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Begin Semantics
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{center}
\begin{tabular}{@{}l | r@{}}
\multicolumn{2}{c}{$(\varsigma \times \sigma) \rightarrow (\varsigma' \times \sigma)$, 
where $\kappa = \sigma(a) , b = alloc(\varsigma) $} \\
\multicolumn{2}{c}{proceed by matching on $\varsigma$} \\
\hline
%%%%% VARLOOKUP EXP
$\langle
x , \rho , a
\rangle$
&$\langle
\mae , \rho , a
\rangle$ \\
& where $\mae = \sigma(\rho(x))$ \\
\hline
%%%%% LAMBDA EXP
$\langle
lam , \rho , a
\rangle$
&$\langle
\textbf{clo}(lam, \rho) , \rho , a 
\rangle$ \\
\hline
%%%%% IF EXP
$\langle
\ifsyn{e_c}{e_t}{e_f} , \rho , a
\rangle$
&$\langle
e_c , \rho , b 
\rangle$ \\
& $\sigma[b \mapsto \textbf{ifk}(e_t , e_f , \rho , a)]$ \\
\hline
%%%%% LET EXP
$\langle
\letsyn{x}{e_x}{e_b} , \rho , a
\rangle$
&$\langle
e_x , \rho , b
\rangle$ \\
& $\sigma[b \mapsto \textbf{letk}(x , e_b , \rho , a)]$ \\
\hline
%%%%% PRIM EXP
$\langle
\primsyn{op}{e_0}{es} , \rho , a
\rangle$
&$\langle
e_0 , \rho , b
\rangle$ \\
& $\sigma[b \mapsto \textbf{appk}([op] ,  es , \rho , a)]$ \\
\hline
%%%%% APPLICATION EXP
$\langle
(e_f \; es ...) , \rho , a
\rangle$
&$\langle
e_f , \rho , b
\rangle$ \\
& $\sigma[b \mapsto \textbf{appk}([] , e_s , \rho , a)]$ \\
\hline
$\langle \mae , \rho , a \rangle$ & \\
match on $\kappa$ below \\
\hline
%%%%% MT KONTINUATION
$ \textbf{mt}$ 
& $\langle \mae , \rho , a \rangle$ \\
\hline
%%%%% IF KONTINUATION FALSE
$ \textbf{ifk}(e_t , e_f , \rho' , c) $ 
& $\langle e_f , \rho' , c \rangle$ \\
where $\mae = \falsesyn$ & \\
\hline
%%%%% IF KONTINUATION TRUE
$ \textbf{ifk}(e_t , e_f , \rho' , c) $ 
& $\langle e_t , \rho' , c \rangle$ \\
where $\mae \not= \falsesyn$ & \\
\hline
%%%%% LET KONTINUATION
$ \textbf{letk}(x , e_b , \rho' , c) $
& $\langle e_b , \rho'[x \mapsto b] , c \rangle$ \\
& $ \sigma[b \mapsto v] $ \\
\hline
%%%%% APP KONTINUATION DONE PRIM
$ \textbf{appk}(op :: \mae_s , [] , \rho' , c) $
& $\langle \mae' , \rho' , c \rangle$ \\
& $ \mae' = op $ applied to $(\mae_s \mdoubleplus [\mae])$ \\
\hline
%%%%% APP KONTINUATION DONE CLO
$ \textbf{appk}((\textbf{clo}(\lamsyn{xs}{e_b} , \rho'') :: \mae_s), $
& $\langle e_b , \rho''[xs_0 \mapsto b_0 ... xs_i \mapsto b_i] , c \rangle$ \\
$\;\;\;\;\;\;\;\;\;\;  [\;] , \rho' , c) $
& $ \mae_s = \mae_s \mdoubleplus [\mae] $ \\
& $ \sigma[b_0 \mapsto \mae_{s0} ... b_i \mapsto \mae_{si}] $  \\
\hline
%%%%% APP KONTINUATION MORE
$ \textbf{appk}(done, e_h::e_t , \rho' , c) $
& $\langle e_h , \rho' , b \rangle$ \\
& $ \sigma[b \mapsto \textbf{appk}(done \mdoubleplus [\mae] , e_t , \rho' , c)] $ \\
\hline
\end{tabular}
\end{center}







\newpage



\section{Formalization of an Abstract CESK* machine with basic Scheme features.}




























\end{document}
  